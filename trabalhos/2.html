<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <title>
        Segundo Trabalho
    </title>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
    <link rel='stylesheet' type='text/css' media='screen' href='../dist/style.css'>
    <script src="../js/p5.min.js"></script>
    <script type="text/javascript">
        function getPointInT(p1, p2, p3, p4, t) {
            /* Para chegar na forma abaixo comecei com a forma da interpolação linear aka lerps
            como a vista em aula:
            A = Lerps entre p1 e p2 em t
            B = Lerps entre p2 e p3 em t
            C = Lerps entre p3 e p4 em t
            D = Lerps entre A e B em t
            E = Lerps entre B e C em t
            Point = Lerps entre D e E em t

            A definição de lerp é a seguinte onde X e Y são pontos constantes e t é um valor entre 0 e 1
            Lerps(t) = (1 - t) * X + t * Y

            Escrevendo a função lerp para sua função matemática temos

            A = (1-t)*p1 + t*p2
            B = (1-t)*p2 + t*p3
            C = (1-t)*p3 + t*p4
            D = (1-t)*A + t*B
            E = (1-t)*B + t*C
            Point = (1-t)*D + t*E

            Juntando tudo ficamos com
            point = (1-t)^3*p1 + 3*(1-t)^2*t*p2 + 3*(1-t)*t^2*p3 + t^3*p4
        
            E por fim simplificando separando os polinômios de t^3, t^2, t e 1
            point = p1( -t³+3t²-3t+1 ) +
                    p2( 3t³-6t²+3t ) +
                    p3( -3t³+3t² ) +
                    p4( t³ )

            é uma interpretação diferente da vista em aula utilizando a interpolação linear,
            mas o resultado é o mesmo. é o melhor é que é mais fácil de deriva.
            */
            const tt = t * t;
            const ttt = t * t * t;
            const x = p1.x * (-ttt + 3 * tt - 3 * t + 1) +
                p2.x * (3 * ttt - 6 * tt + 3 * t) +
                p3.x * (-3 * ttt + 3 * tt) +
                p4.x * ttt;

            const y = p1.y * (-ttt + 3 * tt - 3 * t + 1) +
                p2.y * (3 * ttt - 6 * tt + 3 * t) +
                p3.y * (-3 * ttt + 3 * tt) +
                p4.y * ttt;

            // y = v1 * (-t³ + 3t² - 3t + 1) + v2 * (3t³ - 6t² + 3t) + v3 * (-3t³ + 3t²) + v4 * (t³)
            return createVector(x, y);
        }

        function getPointNormalInT(p1, p2, p3, p4, t) { // Derivative of the bezier curve
            const tt = t * t;
            const x = p1.x * (-3 * tt + 6 * t - 3) +
                p2.x * (9 * tt - 12 * t + 3) +
                p3.x * (-9 * tt + 6 * t) +
                p4.x * 3 * tt;
            const y = p1.y * (-3 * tt + 6 * t - 3) +
                p2.y * (9 * tt - 12 * t + 3) +
                p3.y * (-9 * tt + 6 * t) +
                p4.y * 3 * tt;

            // y = v1 * (-3t² + 6t - 3) + v2 * (9t² - 12t + 3) + v3 * (-9t² + 6t) + v4 * 3t²

            const vector = createVector(x, y);
            return vector.normalize();
        }

        class MoveablePoint {
            constructor(x, y, radius, lockX, lockY) {
                this.pos = createVector(x, y);
                this.dragging = false; // Is the object being dragged?
                this.rollover = false; // Is the mouse over the ellipse?
                this.lockX = lockX; // Lock the x position
                this.lockY = lockY; // Lock the y position
                this.radius = radius; // Radius of the circle

                this.offsetX = 0; // Mouseclick X offset
                this.offsetY = 0; // Mouseclick Y offset
            }

            dist(other) {
                return new p5.Vector.dist(this.pos, other);
            }

            over() {
                // fix the mouse position for webgl coordinates
                const mouse_X = mouseX - width / 2;
                const mouse_Y = mouseY - height / 2;

                // Is mouse over object
                if (mouse_X > this.pos.x - this.radius &&
                    mouse_X < this.pos.x + this.radius &&
                    mouse_Y > this.pos.y - this.radius &&
                    mouse_Y < this.pos.y + this.radius) {
                    this.rollover = true;
                } else {
                    this.rollover = false;
                }
            }

            update() {
                // fix the mouse position for webgl coordinates
                const mouse_X = mouseX - width / 2;
                const mouse_Y = mouseY - height / 2;

                if (this.dragging) {
                    if (!this.lockX) { // If not locked on the x axis
                        this.pos.x = mouse_X + this.offsetX;
                    }
                    if (!this.lockY) { // If not locked on the y axis
                        this.pos.y = mouse_Y + this.offsetY;
                    }
                }
            }

            draw() {
                stroke(0);
                strokeWeight(1);
                // Different fill based on state
                if (this.dragging) {
                    fill(color(0, 200, 0))
                } else if (this.rollover) {
                    fill(color(200, 200, 200))
                } else {
                    fill(color(0, 255, 0))
                }
                ellipse(this.pos.x, this.pos.y, this.radius, this.radius);
            }

            pressed() {
                // fix the mouse position for webgl coordinates
                const mouse_X = mouseX - width / 2;
                const mouse_Y = mouseY - height / 2;


                // Did I click on the circle?
                if (mouse_X > this.pos.x - this.radius && mouse_X < this.pos.x + this.radius && mouse_Y > this.pos.y - this.radius && mouse_Y < this.pos.y + this.radius) {
                    this.dragging = true;
                    // If so, keep track of relative location of click to corner of rectangle
                    this.offsetX = this.pos.x - mouse_X;
                    this.offsetY = this.pos.y - mouse_Y;
                }
            }

            released() {
                // Quit dragging
                this.dragging = false;
            }
        }

        class RollerCoasterTrack {
            /*
                p1,p2,p3,p4 are the control points
                precision is the number of points to be drawn
                p2 and p3 moveable points
            */
            constructor(p1, p2, p3, p4, precision) {
                this.p1 = new MoveablePoint(p1.x, p1.y, 50, true, false);
                this.p2 = new MoveablePoint(p2.x, p2.y, 50, false, false);
                this.p3 = new MoveablePoint(p3.x, p3.y, 50, false, false);
                this.p4 = new MoveablePoint(p4.x, p4.y, 50, true, false);

                this.precision = precision;
                this.points = [];

                // colors
                // trackColor grey
                this.trackColor = color(100, 100, 100);
                // supportColor brown
                this.supportColor = color(100, 50, 0);
            }

            update() {
                this.points = [];
                const tStep = 1 / this.precision;
                for (let t = 0; t <= 1; t += tStep) {
                    this.points.push(getPointInT(this.p1.pos, this.p2.pos, this.p3.pos, this.p4.pos, t));
                }

                // check if mouse is over p2 or p3
                const mouse = createVector(mouseX, mouseY);
                const p2Dist = this.p2.dist(mouse);
                const p3Dist = this.p3.dist(mouse);

                //update control points
                this.p1.update();
                this.p2.update();
                this.p3.update();
                this.p4.update();
            }

            draw() {
                stroke(this.trackColor);
                strokeWeight(20);
                noFill();
                beginShape();
                for (let i = 0; i < this.points.length; i++) {
                    vertex(this.points[i].x, this.points[i].y);
                    point(this.points[i].x, this.points[i].y);
                }
                endShape();

                // draw beams connecting each point to each other
                strokeWeight(10);
                stroke(this.supportColor);
                for (let i = 0; i < this.points.length - 1; i++) {
                    line(this.points[i].x, this.points[i].y, this.points[i + 1].x, this.points[i + 1].y);
                }

                // draw beam connecting each point to the bottom of the screen
                strokeWeight(20);
                for (let i = 0; i < this.points.length; i++) {
                    line(this.points[i].x, this.points[i].y, this.points[i].x, height);
                }

                // draw control points
                this.p1.draw();
                this.p2.draw();
                this.p3.draw();
                this.p4.draw();
            }

            pressed() {
                this.p1.pressed();
                this.p2.pressed();
                this.p3.pressed();
                this.p4.pressed();
            }

            released() {
                this.p1.released();
                this.p2.released();
                this.p3.released();
                this.p4.released();
            }

            over() {
                this.p1.over();
                this.p2.over();
                this.p3.over();
                this.p4.over();
            }
        }

        class RollerCoasterCart {
            constructor(track, texture) {
                this.track = track;
                this.position = createVector(0, 0);
                this.normal = createVector(0, 0);
                this.t = 0;
                this.tStep = 0.01;

                this.texture = texture;
            }

            update() {
                this.position = getPointInT(this.track.p1.pos,
                    this.track.p2.pos,
                    this.track.p3.pos,
                    this.track.p4.pos,
                    this.t);
                this.normal = getPointNormalInT(this.track.p1.pos,
                    this.track.p2.pos,
                    this.track.p3.pos,
                    this.track.p4.pos,
                    this.t);
                this.t += this.tStep;
                if (this.t > 1.25) this.t = -0.25;
            }

            draw() {
                push();
                translate(this.position.x, this.position.y);
                rotate(this.normal.heading());
                // img origin in the middle bottom
                image(this.texture,
                    this.texture.width / -2,
                    -this.texture.height);
                pop();
            }
        }

        class ParkBackground {
            constructor(texture) {
                this.texture = texture
            }

            update() {

            }

            draw() {
                // center the image
                image(this.texture,
                    width / 2 - this.texture.width / 2,
                    -height / 2);
            }

        }

        let track;
        let cart;
        let parkBackground;

        const wSizes = {
            width: 800,
            height: 800
        }

        function mousePressed() {
            track.pressed();
        }

        function mouseReleased() {
            track.released();
        }

        function preload() {
            let backgroundImg = loadImage('assets/RollerCoasterBackGround.jpg');
            let cartTexture = loadImage('assets/RollerCoasterCart.png');
            track = new RollerCoasterTrack(
                createVector(-wSizes.width / 2, wSizes.height / 2), // bottom left - start of the track
                createVector(-wSizes.width / 2 + 100, -wSizes.height / 2 + 100), // top left - control point 2
                createVector(wSizes.width / 2 - 100, -wSizes.height / 2 + 100), // top right - control point 1

                createVector(wSizes.width / 2, wSizes.height / 2), // bottom right - end of the track
                10
            );
            cart = new RollerCoasterCart(track, cartTexture);
            parkBackground = new ParkBackground(backgroundImg);
            // sef frame rate to 1
            //frameRate(1);
        }

        function setup() {
            createCanvas(wSizes.width,
                wSizes.height,
                WEBGL);
            track.update();
        }

        function draw() {
            background(255);

            parkBackground.update();
            parkBackground.draw();

            track.over();
            track.update();
            track.draw();

            cart.update();
            cart.draw();


        }
    </script>
</head>

<body>
    <div class="container">
        <h1>
            Curva de Bezier Quadrática
        </h1>
        <h2>
            Arraste os pontos verdes de controle para alterar a curva.
        </h2>
        <main>
        </main>
        <a class="link" href="/Computacao-Grafica">
            Voltar
        </a>
    </div>
</body>

</html>